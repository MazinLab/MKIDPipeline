import matplotlib.pyplot as plt
import numpy as np
import scipy
from scipy.optimize.minpack import curve_fit
import scipy.constants as con
from scipy.interpolate import griddata


def fitBlackbody(wvls, flux, fraction=1.0, newWvls=None, tempGuess=8600):
    """
    Seth 11/13/14
    Simple blackbody fitting function that returns BB temperature and fluxes if requested.

    INPUTS:
        wvls - wavelengths of data points (in Angstroms!)
        flux - fluxes of data points (in ergs/s/cm^2/Angstrom!)
        fraction - what fraction of spectrum's red end to use for fit. Default is 1.0 (use whole spectrum).
                   for example, fraction=1.0/5.0 only fits BB to last 20% of spectrum.
        newWvls - 1D array of wavelengths in angstroms. If given, function returns blackbody fit at requested points
        tempGuess - manually adjust guess of BB temperature (in Kelvin) that fit starts with

    OUTPUTS:
        T - temperature in Kelvin of blackbody fit
        newFlux - fluxes calculated at newWvls using the BB equation generated by the fit

    """
    c = 3.00E10  # cm/s
    h = 6.626E-27  # erg*s
    k = 1.3806488E-16  # erg/K

    x = wvls
    norm = flux.max()
    y = flux / norm

    # print("BBfit using last ", fraction * 100, "% of spectrum only")
    fitx = x[int((1.0 - fraction) * len(x))::]
    fity = y[int((1.0 - fraction) * len(x))::]

    guess_a, guess_b = 1 / (2 * h * c ** 2 / 1e-9), tempGuess  # Constant, Temp
    guess = [guess_a, guess_b]

    blackbody = lambda fx, N, T: N * 2 * h * c ** 2 / (fx) ** 5 * (
            np.exp(h * c / (k * T * (fx))) - 1) ** -1  # Planck Law
    # blackbody = lambda fx, N, T: N*2*c*k*T/(fx)**4 #Rayleigh Jeans tail
    # blackbody = lambda fx, N, T: N*2*h*c**2/(fx**5) * exp(-h*c/(k*T*fx)) #Wein Approx

    params, cov = curve_fit(blackbody, fitx * 1.0e-8, fity, p0=guess, maxfev=2000)
    N, T = params
    print("BBFit:\nN = %s\nT = %s\n" % (N, T))

    if newWvls is not None:
        best_fit = lambda fx: N * 2 * h * c ** 2 / (fx) ** 5 * (
                np.exp(h * c / (k * T * (fx))) - 1) ** -1  # Planck Law
        # best_fit = lambda fx: N*2*c*k*T/(fx)**4 # Rayleigh Jeans Tail
        # best_fit = lambda fx: N*2*h*c**2/(fx**5) * exp(-h*c/(k*T*fx)) #Wein Approx

        calcx = np.array(newWvls, dtype=float)
        newFlux = best_fit(calcx * 1.0E-8)
        newFlux *= norm
        return T, newFlux
    else:
        return T


def rebin(x, y, binedges):
    """
    Seth Meeker 1-29-2013
    Given arrays of wavelengths and fluxes (x and y) rebins to specified bin size by taking average value of input data within each bin
    use: rebinnedData = rebin(x,y,binedges)
    binedges typically can be imported from a FlatCal after being applied in an Photontable
    returns rebinned data as 2D array:
        rebinned[:,0] = centers of wvl bins
        rebinned[:,1] = average of y-values per new bins
    """
    # must be passed binedges array since spectra will not be binned with evenly sized bins
    start = binedges[0]
    stop = x[-1]
    # calculate how many new bins we will have
    nbins = len(binedges) - 1
    # create output arrays
    rebinned = np.zeros((nbins, 2), dtype=float)
    for i in range(nbins):
        rebinned[i, 0] = binedges[i] + (binedges[i + 1] - binedges[i]) / 2.0
    n = 0
    binsize = binedges[n + 1] - binedges[n]
    while start + (binsize / 2.0) < stop:
        rebinned[n, 0] = (start + (binsize / 2.0))
        ind = np.where((x > start) & (x < start + binsize))
        rebinned[n, 1] = np.mean(y[ind])
        start += binsize
        n += 1
        try:
            binsize = binedges[n + 1] - binedges[n]
        except IndexError:
            break
    return rebinned


def gaussianConvolution(x, y, xEnMin=0.005, xEnMax=6.0, xdE=0.001, fluxUnits="lambda", r=8, nsig_gauss=1, plots=False):
    """
    Seth 2-16-2015
    Given arrays of wavelengths and fluxes (x and y) convolves with gaussian of a given energy resolution (r)
    Input spectrum is converted into F_nu units, where a Gaussian of a given R has a constant width unlike in
    wavelength space, and regridded to an even energy gridding defined by xEnMin, xEnMax, and xdE
    INPUTS:
        x - wavelengths of data points in Angstroms or Hz
        y - fluxes of data points in F_lambda (ergs/s/cm^2/Angs) or F_nu (ergs/s/cm^2/Hz)
        xEnMin - minimum value of evenly spaced energy grid that spectrum will be interpolated on to
        xEnMax - maximum value of evenly spaced energy grid that spectrum will be interpolated on to
        xdE - energy spacing of evenly spaced energy grid that spectrum will be interpolated on to
        fluxUnits - "lambda" for default F_lambda, x must be in Angstroms. "nu" for F_nu, x must be in Hz.
        r - energy resolution of gaussian to be convolved with. R=8 at 405nm by default.
    OUTPUTS:
        xOut - new x-values that convolution is calculated at (defined by xEnMin, xEnMax, xdE), returned in same units as original x
        yOut - fluxes calculated at new x-values are returned in same units as original y provided
    """
    ##=======================  Define some Constants     ============================
    c = con.c * 100  # cm/s
    h = con.h  # erg*s
    k = 1.3806488E-16  # erg/K
    heV = h / con.e
    ##================  Convert to F_nu and put x-axis in frequency  ===================
    if fluxUnits == 'lambda':
        xEn = heV * (c * 1.0E8) / x
        xNu = xEn / heV
        yNu = y * x ** 2 * 3.34E4  # convert Flambda to Fnu(Jy)
    elif fluxUnits == 'nu':
        xNu = x
        xEn = xNu * heV
        yNu = y
    else:
        raise ValueError("fluxUnits must be either 'nu' or 'lambda'")
    ##============  regrid to a constant energy spacing for convolution  ===============
    xNuGrid = np.arange(xEnMin, xEnMax, xdE) / heV  # make new x-axis gridding in constant freq bins
    yNuGrid = griddata(xNu, yNu, xNuGrid, 'linear', fill_value=0)
    xNuGrid = xNuGrid[1:-1]  # remove weird effects with first and last values #TODO figure out why this is happening
    yNuGrid = yNuGrid[1:-1]
    if plots == True:
        plt.plot(xNuGrid, yNuGrid, label="Spectrum in energy space")
    ##======  define gaussian for convolution, on same gridding as spectral data  ======
    # WARNING: right now flux is NOT conserved
    offset = 0
    E0 = heV * c / (900 * 1E-7)  # 450rnm light is ~3eV
    dE = E0 / r
    sig = dE / heV / 2.355  # define sigma as FWHM converted to frequency
    # normalize the Gaussian
    amp = 1.0 / (np.sqrt(2 * np.pi) * sig)
    gaussX = np.arange(-nsig_gauss * sig, nsig_gauss * sig, xdE / heV)
    gaussY = amp * np.exp(-1.0 * (gaussX - offset) ** 2 / (2.0 * (sig ** 2)))
    gaussX = gaussX[1:-1]
    gaussY = gaussY[1:-1]
    window_size = int(len(gaussX) / 2)
    if plots == True:
        plt.plot(gaussX, gaussY * yNuGrid.max(), label="Gaussian to be convolved")
        plt.legend()
        plt.show()
    ##====== Integrate curve to get total flux, required to ensure flux conservation later =======
    originalTotalFlux = scipy.integrate.simps(yNuGrid[window_size:-window_size], x=xNuGrid[window_size:-window_size])
    ##================================    convolve    ==================================
    convY = np.convolve(yNuGrid, gaussY, 'valid')
    if plots:
        plt.plot(xNuGrid, convY, label="Convolved spectrum")
        plt.legend()
        plt.show()
    ##============ Conserve Flux ==============
    newTotalFlux = scipy.integrate.simps(convY, x=xNuGrid[window_size:-window_size])
    convY *= (originalTotalFlux / newTotalFlux)
    ##==================   Convert back to wavelength space   ==========================
    if fluxUnits == 'lambda':
        xOut = c / xNuGrid[window_size:-window_size] * 1E8
        yOut = convY / (xOut ** 2) * 3E-5  # convert Fnu(Jy) to Flambda
    else:
        xOut = xNuGrid[window_size:-window_size]
        yOut = convY
    if plots:
        plt.plot(xOut[xOut < 25000], yOut[xOut < 25000], label="Convolved Spectrum")
        plt.plot(x, y, label="Original spectrum")
        plt.legend()
        plt.ylabel('F_%s' % fluxUnits)
        plt.show()

    return [xOut, yOut]
