"""
parsebin.pyx
Created by KD and JB Sept 2018

This cython module will take an input .bin file and send it to be parsed to
with a .c file and return the data as a python struct. The parsing is
done in a program binlib.c, and finction variables are declared in binlib.h
The parsed data has the full timestamp created from adding the header and
data packet timestamps in the .bin files.

The input .bin file to the function contains both header packets and
"fake photon" data, which is a photon created by the firmware to end an
ethernet frame. The firmware is set to end a frame either when there are
100 photons in the frame or the clock reaches the next 0.5 ms. In the latter
casse, the firmware MUST generate a fake photon to end the frame. These
fake photons are not removed in the binlib.c code (they could be. We remove
them here in the cython file by creating a new numpy array through the
np.delete function. We have to create a new array, even though it is memory
intensive, because you cannot change a numpy array's shape (easily).

File is called by:
    p = parsebin.parse("fname.bin",n)

Returns
    p.base = baseline
    p.phase = phase
    p.tstamp = timestamp
    p.y = ycoord
    p.x = xcoord
    p.roach = roachnum

IF the .c code has been changed, you can recompile it
$ gcc -c binlib.c -O3

When updating this code:
You must also recompile the setup.py file located in the current directory
which containes the information to make(compile) the cythonized file.
(in current repository, in .../MKIDPipeline dir)
$ python setup.py build_ext --inplace

"""

import os
import numpy as np
cimport numpy as np
from time import time

###############################################################################
# Cythonized .h file
# Declare value types in Cython that the binlib.h file needs
# The namespace used here is only relevant to the C files; you do
#  not need to match the namespace in the rest of the .pyx file

cdef extern from "binlib.h":
    long cparsebin(const char *fName, unsigned long max_len, int* baseline, float* wavelength, unsigned long* timestamp, unsigned int* ycoord, unsigned int* xcoord, unsigned int* roach)

###############################################################################
# Calling binlib and passing it stuff
#####################################

def _parse(file, _n=0):

    # Creating pointers to memory bocks that the binlib.c code will fill
    n = int(max(os.stat(file).st_size/8, _n))
    baseline   = np.empty(n, dtype=np.int)
    wavelength = np.empty(n, dtype=np.float32)
    timestamp  = np.empty(n, dtype=np.uint64)
    y = np.empty(n, dtype=np.uint32)
    x = np.empty(n, dtype=np.uint32)
    roachnum = np.empty(n, dtype=np.uint32)

    # Calling parsebin from binlib.c
    # npackets is the number of real+fake photons processed by binlib.c
    npackets = cparsebin(file.encode('UTF-8'), n,
                 <int*>np.PyArray_DATA(baseline),
                 <float*>np.PyArray_DATA(wavelength),
                 <unsigned long*>np.PyArray_DATA(timestamp),
                 <unsigned int*>np.PyArray_DATA(y),
                 <unsigned int*>np.PyArray_DATA(x),
                 <unsigned int*>np.PyArray_DATA(roachnum))
    #print("number of parsed photons = {}".format(npackets))
    #r = cparsebin(file.encode('UTF-8'), n, &baseline[0], &wavelength[0], &timestamp[0],&y[0], &x[0], &roachnum[0])

    # Raising Errors
    if npackets>n:
        return parse(file,abs(npackets))
    elif npackets<0:
        errors = {-1:'Data not found'}
        raise RuntimeError(errors.get(npackets,'Unknown Error: {}'.format(npackets)))

    # Create new struct from output from binlib.c
    # What this does is only grab the elements of the arrays that are real valued
    # This essentially clips the data since we declared it to be as long as the .bin
    #  file, but some of those lines were headers, which are now empty in the returned arrays
    #  We also combine the arrays into a single struct. It's a for loop, but its actually a fast one
    dt  = np.dtype([('baseline', int),('phase', float), ('tstamp', np.float64),
                    ('y', int), ('x', int),('roach', int)])

    # Remove Fake Photons
    #   fake photons translate to x=511 when you read the bitvalues as numbers
    #   we just throw them away since they aren't useful to anybody
    use = x!=511
    use[npackets:]=False


    cdef p = np.zeros(use.sum(),dtype=dt)
    for name, x in zip(dt.names, [baseline[use],wavelength[use],
                                  timestamp[use],y[use],x[use],roachnum[use]]):
        p[name] = x
    p = p.view(np.recarray)

    return p

#####################################################################################################
#####################################################################################################
# Python Manipulation of Parsed Files
#####################################################################################################
#####################################################################################################


##########################
# Methods of JebsParse
#########################
def _makephasecube(x, y, phase, shape, n_phases):
    phs_range = np.linspace(-np.pi, np.pi, n=n_phases)
    shape = (shape[0], shape[1], n_phases)
    phs_cube = np.zeros(shape)

    tic = time()
    for x,y in zip(x,y,phase):
        for z,ph in enumerate(phs_range):
            #if ph
            phs_cube[x,y,z] += 1
    toc = time()
    print("Making phase cube of single bin file took {} seconds".format(toc-tic))

    return phs_cube


def parsebin(files, shape):
    """ files must be a single file or a list of files """
    if isinstance(files, str):
        files=[files]
    return ParsedBinCollection(files, shape)


##########################
# Classes of JebsParse
#########################


class ParsedBin(object):
    """
    Parse a Single .bin File
    Assume basePath points to data directory

    input: a single file, full path name specified

    output: a numpy object
        Attributes:
        .name = input file name
        .tstamp = list of photon arrival times (info from header+photon .5ms time)
        .phase = list of phases (not yet wavelength cal-ed)
        .baseline = list of baselines
        .roach_num = list of roach #s
        .x = list of x coordinates
        .y = list of y coordinates

    """
    def __init__(self, file, shape):
        self.shape = shape
        self.file = file
        parsef = _parse(file)
        self.x = parsef.x
        self.y = parsef.y
        self.tstamp = parsef.tstamp
        self.baseline = parsef.baseline
        self.phase = parsef.phase
        self.roach = parsef.roach
        self.nphotons = parsef.x.size

    @property
    def imagecube(self):
        ret = np.zeros(self.shape, dtype=np.uint16)
        for x, y in zip(self.x, self.y):
            ret[y, x] += 1
        return ret

    def phasecube(self, n_phases):
        return _makephasecube(self.x,self.y,self.phase, self.shape, n_phases)

    def reshape(self, newshape):
        if newshape[0]<self.x.max() or newshape[1]<self.x.max():
            raise ValueError('Bad shape')
        self.shape = newshape


class ParsedBinCollection(object):
    def __init__(self, files, shape=None):
        self._shape = shape
        self._data = None
        self._phasecube = None
        self.parsed_bins = [ParsedBin(f) for f in self.files]

    def phasecube(self, n_phases):
        if self._phasecube is None or n_phases==self._phasecube.shape[-1]:
            return self._phasecube

        x = np.concatenate([b.x for b in self.parsed_bins])
        y = np.concatenate([b.x for b in self.parsed_bins])
        phase = np.concatenate([b.phase for b in self.parsed_bins])
        self._phasecube = _makephasecube(x,y,phase,self._shape,n_phases)

        return self._phasecube

    @property
    def imagecube(self):
        return np.concatenate([b.image for b in self.parsed_bins])

    def reshape(self, newshape):
        for b in self.parsed_bins:
            b.reshape(newshape)

    @property
    def nphotons(self):
        return sum([b.nphotons for b in self.parsed_bins])


